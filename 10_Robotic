import math 
import gurobipy as gp 
from gurobipy import GRB
from gurobipy import nlfunc

# Paramètres 
L1, L2 = 1.0, 0.8
x_star, y_star = 1.20, 0.60 
xo, yo, r = 0.50, 0.00, 0.20

# Joint limits 
theta_1_min, theta_1_max = -math.pi, math.pi
theta_2_min, theta_2_max = -0.75 * math.pi, 0.75 * math.pi 

# Build Model 
m = gp.Model("robotic_arm")

# Décision variables 
theta_1 = m.addVar(lb=theta_1_min, ub=theta_1_max, vtype=GRB.CONTINUOUS, name="theta1")
theta_2 = m.addVar(lb=theta_2_min, ub=theta_2_max, vtype=GRB.CONTINUOUS, name="theta2")
x = m.addVar(vtype=GRB.CONTINUOUS, name="x")
y = m.addVar(vtype=GRB.CONTINUOUS, name="y")
xm = m.addVar(vtype=GRB.CONTINUOUS, name="xm")
ym = m.addVar(vtype=GRB.CONTINUOUS, name="ym")



m.addConstr(x == L1*nlfunc.cos(theta_1) + L2*nlfunc.cos(theta_1 + theta_2))
m.addConstr(y == L1*nlfunc.sin(theta_1) + L2*nlfunc.sin(theta_1 + theta_2))

m.addConstr(xm == (L1/2)*nlfunc.cos(theta_1))
m.addConstr(ym == (L1/2)*nlfunc.sin(theta_1))

# Contraintes obstacle et cible
m.addConstr((xm - xo)*(xm - xo) + (ym - yo)*(ym - yo) >= r*r)
m.addConstr(x == x_star)
m.addConstr(y == y_star)

# Fonction objectif
m.setObjective((x - x_star)*(x - x_star) + (y - y_star)*(y - y_star), GRB.MINIMIZE)

# Optimisation
m.optimize()

sol = None
if m.Status == GRB.OPTIMAL:
    sol = {
        "theta1": theta_1.X, "theta2": theta_2.X,
        "x": x.X, "y": y.X, "xm": xm.X, "ym": ym.X,
        "obj": m.ObjVal,
    }
    print("Optimal objective:", m.ObjVal)
    print(sol)
else:
    print("Optimization status:", m.Status)


import matplotlib.pyplot as plt

def draw_arm(ax, L1, L2, th1, th2, xo, yo, r, x_star, y_star, title):
    x1 = L1*math.cos(th1)
    y1 = L1*math.sin(th1)
    x2 = x1 + L2*math.cos(th1 + th2)
    y2 = y1 + L2*math.sin(th1 + th2)

    ax.plot([0, x1], [0, y1], linewidth=3)
    ax.plot([x1, x2], [y1, y2], linewidth=3)
    ax.scatter([0, x1, x2], [0, y1, y2], s=40)

    # obstacle
    t = [i*2*math.pi/300 for i in range(301)]
    cx = [xo + r*math.cos(tt) for tt in t]
    cy = [yo + r*math.sin(tt) for tt in t]
    ax.plot(cx, cy, linewidth=2)

    # target
    ax.scatter([x_star], [y_star], marker='x', s=80)

    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(-0.5, L1+L2+0.2)
    ax.set_ylim(-0.5, L1+L2+0.2)
    ax.grid(True, linestyle=':')
    ax.set_title(title)

import os

# Crée le dossier s'il n'existe pas
os.makedirs("images", exist_ok=True)

# Maintenant on peut sauvegarder l'image
plt.savefig("images/robot-arm.png", dpi=100, bbox_inches="tight")


if sol is not None:
    fig, ax = plt.subplots(figsize=(6,6))
    draw_arm(ax, L1, L2, sol['theta1'], sol['theta2'], xo, yo, r, x_star, y_star,
             title=f"Robot Arm (nlfunc)\nobj={sol['obj']:.4g}")
    # Save as PNG instead of showing
    plt.savefig("images/robot-arm.png", dpi=100, bbox_inches="tight")
    plt.close(fig)
else:
    print("No solution available to plot yet.")
